// Generated by CoffeeScript 2.3.1
(function() {
  var PascalTri, bgcol, binomMod, ch, clearCanvas, col_array, container, cw, el, endColor, fullLColor, gui, guiparam, lColor, m, mPI, mabs, matan, math, mceil, mcos, mfloor, mhrt, mmax, mmin, mrandom, mround, msin, msqrt, n, numberColor, plineColor, plineWidth, redraw, startColor, tctx, tri, trianglescanvas, wlineWidth;

  math = Math;

  mcos = math.cos;

  msin = math.sin;

  mabs = math.abs;

  mround = math.round;

  matan = math.atan2;

  msqrt = math.sqrt;

  mmin = math.min;

  mmax = math.max;

  mPI = math.PI;

  mrandom = math.random;

  mfloor = math.floor;

  mceil = math.ceil;

  mhrt = msin(mPI / 3);

  Array.prototype.randomElement = function() {
    return this[mrandom() * this.length | 0];
  };

  Array.prototype.nextRow = function() {
    var a, i;
    a = (function() {
      var j, ref, results;
      results = [];
      for (i = j = 1, ref = this.length; (1 <= ref ? j < ref : j > ref); i = 1 <= ref ? ++j : --j) {
        results.push(this[i - 1] + this[i]);
      }
      return results;
    }).call(this);
    a.push(1);
    a.unshift(1);
    return a;
  };

  Array.prototype.nextRowMod = function(m) {
    var a, i;
    a = (function() {
      var j, ref, results;
      results = [];
      for (i = j = 1, ref = this.length; (1 <= ref ? j < ref : j > ref); i = 1 <= ref ? ++j : --j) {
        results.push((this[i - 1] + this[i]) % m);
      }
      return results;
    }).call(this);
    a.push(1);
    a.unshift(1);
    return a;
  };

  Array.prototype.last = function() {
    return this[this.length - 1];
  };

  binomMod = function(n, m) {
    var binoms;
    binoms = [[1]];
    while (binoms.length < n) {
      binoms.push(binoms.last().nextRowMod(m));
    }
    return binoms;
  };

  PascalTri = class PascalTri {
    constructor(n, el, m) {
      this.labels = new Array;
      this.ul = el / (n - 1);
      this.translatey = -0.4 * el;
      this.translatex = 0;
      this.m = m;
      this.n = n;
    }

    drawCircles(ctx, carray, binmod, shown, nc, fc) {
      var j, k, ref, ref1, x, y;
      ctx.save();
      ctx.translate(this.translatex, this.translatey);
      for (y = j = 0, ref = this.n; (0 <= ref ? j < ref : j > ref); y = 0 <= ref ? ++j : --j) {
        for (x = k = 0, ref1 = y; (0 <= ref1 ? k <= ref1 : k >= ref1); x = 0 <= ref1 ? ++k : --k) {
          ctx.beginPath();
          ctx.arc(x * this.ul - y * this.ul / 2, y * this.ul * mhrt, this.ul / 2, 0, 2 * mPI);
          if (fc) {
            ctx.fillStyle = carray[binmod[y][x]];
            ctx.fill();
          } else {
            ctx.strokeStyle = carray[binmod[y][x]];
            ctx.stroke();
          }
          if (shown) {
            ctx.fillStyle = nc;
            ctx.fillText(binmod[y][x], x * this.ul - y * this.ul / 2, y * this.ul * mhrt, this.ul / 2);
          }
        }
      }
      // ctx.beginPath()
      // ctx.arc(-el/2,el*mhrt,@ul/2,0,2*mPI)
      // ctx.fillStyle = "#880000"
      // ctx.fill()
      // ctx.beginPath()
      // ctx.arc(el/2,el*mhrt,@ul/2,0,2*mPI)
      // ctx.fillStyle = "#008800"
      // ctx.fill()
      // ctx.beginPath()
      // ctx.arc(0,0,@ul/2,0,2*mPI)
      // ctx.fillStyle = "#000088"
      // ctx.fill()
      return ctx.restore();
    }

    drawTriangles(ctx) {
      var j, k, ref, ref1, x, y;
      ctx.save();
      ctx.translate(this.translatex, this.translatey);
      for (x = j = 0, ref = n; (0 <= ref ? j < ref : j > ref); x = 0 <= ref ? ++j : --j) {
        for (y = k = 0, ref1 = n - x; (0 <= ref1 ? k < ref1 : k > ref1); y = 0 <= ref1 ? ++k : --k) {
          ctx.beginPath();
          ctx.moveTo(x * this.ul, -y * this.ul);
          ctx.lineTo((x + 1) * this.ul, -y * this.ul);
          ctx.lineTo(x * this.ul, -(y + 1) * this.ul);
          ctx.closePath();
          ctx.stroke();
        }
      }
      return ctx.restore();
    }

  };

  
  // drawLabels: (ctx) ->
  //         ctx.save()
  //         ctx.translate(@translatex, @translatey)
  //         for x in [0..n]
  //                 for y in [0..n-x]
  //                         ctx.fillText(@labels[x][y], x*@ul, -y*@ul)
  //         ctx.restore()
  cw = window.innerWidth;

  ch = window.innerHeight;

  container = document.createElement('div');

  document.body.appendChild(container);

  // もうちょっとよいやり方があるだろう
  // fullcanvas = document.createElement('canvas')
  // container.appendChild(fullcanvas)
  // fullcanvas.width = cw
  // fullcanvas.height = ch
  // fctx = fullcanvas.getContext "2d"
  // fctx.transform(1,0,-mcos(mPI/3),msin(mPI/3),0.5*cw,0.5*ch)
  trianglescanvas = document.createElement('canvas');

  container.appendChild(trianglescanvas);

  trianglescanvas.width = cw;

  trianglescanvas.height = ch;

  tctx = trianglescanvas.getContext("2d");

  tctx.transform(1, 0, 0, 1, 0.5 * cw, 0.5 * ch);

  tctx.textAlign = "center";

  tctx.textBaseline = "middle";

  // labelscanvas = document.createElement('canvas')
  // container.appendChild(labelscanvas)
  // labelscanvas.width = cw
  // labelscanvas.height = ch
  // lctx = labelscanvas.getContext "2d"
  // lctx.transform(1,0,-mcos(mPI/3),msin(mPI/3),0.5*cw,0.5*ch)
  clearCanvas = function(ctx) {
    ctx.save();
    ctx.setTransform(1, 0, 0, 1, 0, 0);
    ctx.clearRect(0, 0, cw, ch);
    return ctx.restore();
  };

  
  // フォントや色はこちらで設定

  // lctx.textAlign = "center"
  // lctx.textBaseline = "middle"
  // lctx.font = '20pt Arial'
  // fctx.font = '40pt Arial'
  bgcol = '#ffffff';

  // full labeled triangle color
  fullLColor = '#ff6e00bb';

  // color for labels
  lColor = "#9000c0";

  // wall line width
  wlineWidth = 2;

  // path line
  plineColor = "red";

  plineWidth = 4;

  // edge length of the outer triangle
  el = 0.8 * mmin(cw, ch);

  // number of edge subdivision
  n = 4;

  // modulo
  m = 2;

  numberColor = "#ffffff";

  startColor = "#ffffff";

  endColor = "#0000ff";

  tri = new PascalTri(n, el, m);

  guiparam = {
    steps: n,
    mod: m,
    showNumber: true,
    numberColor: numberColor,
    fillCircle: true,
    startColor: startColor,
    endColor: endColor,
    naturalGradation: false
  };

  gui = new dat.GUI();

  gui.add(guiparam, 'steps', 2, 256, 1).onChange(function(val) {
    redraw(val);
  });

  gui.add(guiparam, 'mod', 2, 15, 1).onChange(function(val) {
    redraw(val);
  });

  gui.add(guiparam, 'showNumber').onChange(function(val) {
    redraw(val);
  });

  gui.addColor(guiparam, 'numberColor').onChange(function(val) {
    redraw(val);
  });

  gui.add(guiparam, 'fillCircle').onChange(function(val) {
    redraw(val);
  });

  gui.addColor(guiparam, 'startColor').onChange(function(val) {
    redraw(val);
  });

  gui.addColor(guiparam, 'endColor').onChange(function(val) {
    redraw(val);
  });

  gui.add(guiparam, 'naturalGradation').onChange(function(val) {
    redraw(val);
  });

  col_array = function(sc, ec, m, nat = true) {
    var eci, ecs, i, sci, scs;
    if (nat) {
      scs = (function() {
        var j, len, ref, results;
        ref = [1, 3, 5];
        results = [];
        for (j = 0, len = ref.length; j < len; j++) {
          i = ref[j];
          results.push(parseInt(sc.substring(i, i + 2), 16));
        }
        return results;
      })();
      ecs = (function() {
        var j, len, ref, results;
        ref = [1, 3, 5];
        results = [];
        for (j = 0, len = ref.length; j < len; j++) {
          i = ref[j];
          results.push(parseInt(ec.substring(i, i + 2), 16));
        }
        return results;
      })();
      return (function() {
        var j, ref, results;
        results = [];
        for (i = j = 0, ref = m; (0 <= ref ? j < ref : j > ref); i = 0 <= ref ? ++j : --j) {
          results.push('#' + (mfloor((i * ecs[0] + (m - 1 - i) * scs[0]) / (m - 1))).toString(16).padStart(2, '0') + (mfloor((i * ecs[1] + (m - 1 - i) * scs[1]) / (m - 1))).toString(16).padStart(2, '0') + (mfloor((i * ecs[2] + (m - 1 - i) * scs[2]) / (m - 1))).toString(16).padStart(2, '0'));
        }
        return results;
      })();
    } else {
      sci = parseInt(sc.substring(1), 16);
      eci = parseInt(ec.substring(1), 16);
      return (function() {
        var j, ref, results;
        results = [];
        for (i = j = 0, ref = m; (0 <= ref ? j < ref : j > ref); i = 0 <= ref ? ++j : --j) {
          results.push('#' + (mfloor((i * eci + (m - 1 - i) * sci) / (m - 1))).toString(16).padStart(6, '0'));
        }
        return results;
      })();
    }
  };

  redraw = function(val) {
    var carray, ec, fc, nc, ng, sc, shown;
    // {n,m,shown,nc,sc,ec,ng} = guiparam
    n = guiparam.steps;
    m = guiparam.mod;
    shown = guiparam.showNumber;
    nc = guiparam.numberColor;
    fc = guiparam.fillCircle;
    sc = guiparam.startColor;
    ec = guiparam.endColor;
    ng = guiparam.naturalGradation;
    carray = col_array(sc, ec, m, ng);
    tri = new PascalTri(n, el, m);
    
    // # full label
    // clearCanvas(fctx)
    // fctx.save()
    // fctx.fillStyle = fullLColor
    // tri.fillFullLabel(fctx)
    // fctx.restore()

    // triangle
    clearCanvas(tctx);
    tri.drawCircles(tctx, carray, binomMod(n, m), shown, nc, fc);
  };

  // # labels
  // clearCanvas(lctx)
  // lctx.save()
  // lctx.fillStyle = lColor
  // tri.drawLabels(lctx)
  // lctx.restore()
  redraw();

}).call(this);
